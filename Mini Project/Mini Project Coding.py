# -*- coding: utf-8 -*-
"""Final code mini project computational physics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yctIgrvBddTA-uaBqLoP4Nex0iMyIqE_
"""

""""

This code was written by Ahmad Aiman Mohd Nazir (17060060) for computational physics course mini project. 
In this code we are going to solve for nonhomogenous linear ODEs where 
it genaral form can be written as follow my'' + by' + ky = f(x) and
for this ODE, the physics problem that we are going to solve is related to 
forced vibration on the spring. Liner ODEs is y'' + 8y' +16y = 8sin(4x), 
the exact solution of this ODEs is y(x) = 1/4e^(-4x) + xe^(-4x) -1/4cos(4x)

The method that we are going to use here is finite difference method. 
The general expression of ODEs can be represented as x'' + P(x)x' + q(x)x = f(x)
Author : Ahmad Aiman Mohd Nazir

"""

#import the relevent libraries
from scipy.linalg import solve
import  numpy as np
import matplotlib.pyplot as plt
x = [0]     #set the initial value of x and define all parameters
f = []        #f(x)
n = 20         #number of iterations 
h = 1/n      #step size or increment
p = -8       #p(x)
q = -16      #q(x)
u = 0        #y(0)
u_1 = 0.1863   #y(1.0)

#define matrix zeros with size (n-1)x(n-1)
A = np.zeros((n-1,n-1))

#define matrix zeros with size (n-1)x(1)
B = np.zeros((n-1,1))

#append x values into array x by using loop
for i in range (0,n):
    x.append(x[i]+h)
    i+=1

for i in range (0,n):
  f.append(8*np.sin(4*x[i]))
  i+=1

#calculate the coefficient for tridiagonal matrix
a = 2+ q*h**2
b = -(1-1/2*p*h)
c = -(1+1/2*p*h)

#input the values obtain from a,b and c into matrix A
for i in range(0,n-1):
    for j in range(0,n-1):
        if i == j:
            A[i][j] = a
        elif i<j and j-i==1:
            A[i][j] = b
        elif i>j and i-j==1:
            A[i][j] = c
        else:
            A[i][j] = 0
    j+=1
i+=1

#input the values into matrix B
for i in range(0,n-1):
    for j in range(0,1):
        if i == j:
            B[i][j] = (1+(1/2)*p*h)*u - h**2*f[i+1]
        elif i > j and i<= n-3:
            B[i][j] = -(h**2)*f[i+1]
        elif i > j and i == n-2:
            B[i][j] = (1-(1/2)*p*h)*u_1 - (h**2)*f[i+1]
    j+=1
i+=1

X = solve(A,B)              #solve matrix AX = B

xnew = np.arange(0,1.01,h)  #define new array for x, ranging from 0 to 1 with increment = h

y1 = np.insert(X,0,0)       #insert value y = 0 into y1[0]
ynew = np.append(y1,0.1863)     #append value y = 0.1863 in y1 array


#plot the graph ynew vs xnew
plt.plot(xnew,ynew,'-og',label='Approximate solution')


#define the exact solution
def exact(x):
    return 1/4*np.exp(-4*x) + x*np.exp(-4*x) - 1/4*np.cos(4*x)

xexact = list(np.arange(0.0,1.01,0.01))
    
#calculate the yexact values for each x
yexact = []
for i in xexact:
  yexact.append(exact(i))

plt.plot(xexact,yexact,'-k',label='exact solution')
plt.legend()
plt.xlabel('x')
plt.ylabel('y(x)')
plt.title('Plot y(x) versus x for ODE: '"$y''+8y'+16y = 8sin(4x)$")
plt.show()